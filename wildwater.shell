#!/bin/bash


images() {
  # Fonction générant l'histogramme des 10 plus grandes et 50 plus petites usines sous le format PNG
  # prend le nom d'un fichier de données en argument et va générer deux images à partir de celui si
  # le fichier de données est trié dans l'ordre décroissant des volumes dans un fichier temporaire
  # avant d'être séparé en deux autres fichiers temporaires contenant les 10 usines avec les volumes
  # les plus grands ainsi que les 50 usines avec les volumes les plus petits
  # tout les fichiers temporaires sont supprimés à la fin
  # les fichiers générés sont déplacés dans le dossier 'images'
  
  donnees="$1"
  
  if [ ! -r "$donnees".dat ] ; then
    echo "Erreur : le fichier histogramme généré par le programme C n'existe pas ou n'est pas lisible"
    exit 1
  fi

  # Ici, le fichier de données en argument est coupé par 'tail' afin de ne prendre ses données
  # qu'à partir de la seconde ligne (pour passer la ligne du format des données)
  # ces données sont triées par 'sort' par ordre numérique en fonction de la deuxième colonne
  # et le résultat est inversé afin d'avoir les données en ordre décroissant
  # ces données ainsi obtenues sont ensuite traitées par 'awk' afin de les mettres sous une
  # forme traitable par gnuplot, les espaces présents dans l'id de l'usine sont enlevés
  # les ';' séparants les deux colonnes sont remplacés par des espaces et les données
  # finalement obtenues sont envoyées dans le fichier 'temp.dat'
  awk -F';' '{gsub(/ /, "", $1); printf "%s %d\n", $1, $2}' <(tail -n+2 "$donnees".dat | sort -t';' -k2,2nr) > temp.dat

  head -n 10 temp.dat > gtemp.dat
  tail -n 50 temp.dat > ptemp.dat

  if [ ! -e "images" ] || [ ! -d "images" ] ; then
    mkdir "images"
  fi
  
  gnuplot plotgrand.gp
  mv retour.png grandes_"$donnees".png
  mv grandes_"$donnees".png images/
  
  gnuplot plotpetit.gp
  mv retour.png petites_"$donnees".png
  mv petites_"$donnees".png images/
  
  rm temp.dat
  rm gtemp.dat
  rm ptemp.dat
  
  return 0
}


histogrammeMax() {
  # Fonction fournissant au programme C son argument, càd le chemin du fichier de données
  # ainsi que 'histo' et 'max' pour que le programme C exécute la bonne fonction
  # appelle la fonction shell génératrice d'images si le programme C ne rencontre pas de problème

  if [ ! -r "$1" ] ; then
    echo "Erreur : le chemin d'accès au fichier est incorrect ou le script n'y a pas accès en lecture"
    exit 1

  else 
    ./projet_final histo "$1" max

    if [ "$?" != '0' ] ; then
      echo "Erreur : code retour de la partie histogramme du programme C non égal à 0"
      exit 1

    else
      images vol_max
    fi
  fi

  return 0
}


histogrammeSrc() {
  # Fonction fournissant au programme C son argument, càd le chemin du fichier de données
  # ainsi que 'histo' et 'src' pour que le programme C exécute la bonne fonction
  # appelle la fonction shell génératrice d'images si le programme C ne rencontre pas de problème

  if [ ! -r "$1" ] ; then
    echo "Erreur : le chemin d'accès au fichier est incorrect ou le script n'y a pas accès en lecture"
    exit 1
    
  else 
    ./projet_final histo "$1" src

    if [ "$?" != '0' ] ; then
      echo "Erreur : code retour de la partie histogramme du programme C non égal à 0"
      exit 1

    else
      images vol_src
    fi
  fi

  return 0
}


histogrammeReal() {
  # Fonction fournissant au programme C son argument, càd le chemin du fichier de données
  # ainsi que 'histo' et 'real' pour que le programme C exécute la bonne fonction
  # appelle la fonction shell génératrice d'images si le programme C ne rencontre pas de problème

  if [ ! -r "$1" ] ; then
    echo "Erreur : le chemin d'accès au fichier est incorrect ou le script n'y a pas accès en lecture"
    exit 1

  else 
    ./projet_final histo "$1" real

    if [ "$?" != '0' ] ; then
      echo "Erreur : code retour de la partie histogramme du programme C non égal à 0"
      exit 1

    else
      images vol_real
    fi
  fi

  return 0
}


histogramme() {
  # Fonction appelant une autre fonction dans le script shell correspondante à 
  # l'argument secondaire de l'histogramme càd une fonction pour max, src, et real

  if [ ! -r "$1" ] ; then
    echo "Erreur : le chemin d'accès au fichier est incorrect ou le script n'y a pas accès en lecture"
    exit 1
  fi

  case $2 in
    'max') histogrammeMax "$1" ;;
    'src') histogrammeSrc "$1" ;;
    'real') histogrammeReal "$1" ;;
    *) echo "Erreur : les instructions à faire exécuter sont incorrectes"
    exit 1 ;;
  esac

  return 0
}


leaks() {
  # Fonction fournissant au programme C ses deux arguments,
  # le chemin d'accès au fichier de données CSV en premier argument
  # et l'identifiant d'une usine comme second argument ainsi que 'leaks' pour que le programme
  # C exécute la bonne fonction

  if [ ! -r "$1" ] ; then
    echo "Erreur : le chemin d'accès au fichier est incorrect ou le script n'y a pas accès en lecture"
    exit 1

  elif [ -z "$2" ] ; then
    echo "Erreur : l'identifiant de l'usine pour les fuites est vide"
    exit 1

  else
    if [ ! -e "donnees" ] || [ ! -d "donnees" ] ; then
      mkdir "donnees"
    fi
    
    cd donnees
    if [ -e "leaks.dat" ] ; then
      mv leaks.dat ../
    fi
    cd ..
    
    ./projet_final 'leaks' "$1" "$2"

    if [ "$?" != '0' ] ; then
      echo "Erreur : code retour de la partie fuite du programme C non égal à 0"
      exit 1
    fi

    if [ -e "leaks.dat" ] ; then
      mv leaks.dat donnees/
    fi
  fi

  return 0
}


# Recompilation du programme C avec make si celui si n'existe pas
if [ ! -x 'projet_final' ] ; then
  echo "Recompilation du programme C.."
  
  if [ -d "codesource" ] ; then
    cd codesource
  else
    echo "Erreur : le dossier codesource n'est pas présent"
    exit 1
  fi
  
  if [ -e "Makefile" ] ; then
    make
  else
    echo "Erreur : le fichier Makefile n'est pas présent"
    exit 1
  fi
  if [ ! -x 'projet_final' ] ; then
    echo "Erreur : les fichiers pour la compilation du programme C ne sont pas tous présents"
    exit 1
  fi

  mv "projet_final" ../

  # Précaution pour enlever les fichiers du makefile
  rm -f avl.o
  rm -f histogramme.o
  rm -f leaks.o
  rm -f main.o
  rm -f outils.o
  rm -f usine.o

  cd ..
  echo "Recompilation réussie"
fi

# Vérification des scripts gnuplots
if [ ! -e "plotgrand.gp" ] || [ ! -e "plotpetit.gp" ] ; then
  echo "Erreur : les script gnuplots sont absents"
  exit 1
fi

# Vérification du nombre d'arguments passés dans le script
if [ $# -ne 3 ] ; then
  echo "Erreur : le script shell prend 3 arguments"
  exit 1
fi

# Vérification du premier argument (le fichier CSV de données existe et est accessible en lecture)
if [ ! -r "$1" ] ; then
  echo  "Erreur : le chemin d'accès au fichier est incorrect ou le script n'y a pas accès en lecture"
  exit 1
fi

# Vérification que le second argument est égal à 'histo' ou 'leaks' et appel de la fonction correspondante
case $2 in
  'histo') histogramme "$1" "$3" ;;
  'leaks') leaks "$1" "$3" ;;
  *) echo "Erreur : les instructions à faire exécuter sont incorrectes"
  exit 1 ;;
esac

# Déplace les fichiers de données créés dans un dossier
if [ ! -e "donnees" ] || [ ! -d "donnees" ] ; then
  mkdir "donnees"
fi

if [ -e "vol_real.dat" ] ; then
  mv vol_real.dat donnees/
fi

if [ -e "vol_src.dat" ] ; then
  mv vol_src.dat donnees/
fi

if [ -e "vol_max.dat" ] ; then
  mv vol_max.dat donnees/
fi

echo "Opération réussie"
